package cryptography

import (
	"github.com/greenstatic/openspalib/tools"
	"testing"
)

func TestAES_256_CBC_encrypt(t *testing.T) {

	tests := []struct {
		inputDataPlainText []byte
		inputDataKey       []byte
		inputDataIV        []byte
		expectedErr        bool
		expectedResult     []byte
		onErrorStr         string
	}{
		{
			[]byte{0x65, 0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x70, 0x6C, 0x61, 0x69, 0x6E, 0x74,
				0x65, 0x78, 0x74},
			[]byte{0x63, 0x68, 0x61, 0x6E, 0x67, 0x65, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x70, 0x61,
				0x73, 0x73},
			[]byte{0x92, 0xC8, 0x00, 0xA7, 0xEF, 0xE4, 0xD7, 0xF3, 0x5A, 0x76, 0x8D, 0x90, 0x4E, 0x51,
				0x37, 0xCB},
			false,
			[]byte{0x92, 0xC8, 0x00, 0xA7, 0xEF, 0xE4, 0xD7, 0xF3, 0x5A, 0x76, 0x8D, 0x90, 0x4E, 0x51,
				0x37, 0xCB, 0x9D, 0xB6, 0xCB, 0x3A, 0xC0, 0x1B, 0xA9, 0xA8, 0xE4, 0xC6, 0xEA, 0x78, 0x29, 0x4F, 0xA5,
				0x4A},
			"failed to encrypt valid plaintext",
		},
		{
			[]byte{0x65, 0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x70, 0x6C, 0x61, 0x69, 0x6E, 0x74,
				0x65, 0x78},
			[]byte{0x63, 0x68, 0x61, 0x6E, 0x67, 0x65, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x70, 0x61,
				0x73, 0x73},
			[]byte{0x92, 0xC8, 0x00, 0xA7, 0xEF, 0xE4, 0xD7, 0xF3, 0x5A, 0x76, 0x8D, 0x90, 0x4E, 0x51,
				0x37, 0xCB},
			true,
			[]byte{},
			"failed to return error when plain text is too short",
		},
		{
			[]byte{0x65, 0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x70, 0x6C, 0x61, 0x69, 0x6E, 0x74,
				0x65, 0x78, 0x74},
			[]byte{0x63, 0x68, 0x61, 0x6E, 0x67, 0x65, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x70, 0x61,
				0x73, 0x73},
			[]byte{0x92, 0xC8, 0x00, 0xA7, 0xEF, 0xE4, 0xD7, 0xF3, 0x5A, 0x76, 0x8D, 0x90, 0x4E, 0x51,
				0x37},
			true,
			[]byte{},
			"failed to return error when IV is too short",
		},
		{
			[]byte{0x65, 0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x70, 0x6C, 0x61, 0x69, 0x6E, 0x74,
				0x65, 0x78, 0x74},
			[]byte{0x63, 0x68, 0x61, 0x6E, 0x67, 0x65, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x70, 0x61,
				0x73},
			[]byte{0x92, 0xC8, 0x00, 0xA7, 0xEF, 0xE4, 0xD7, 0xF3, 0x5A, 0x76, 0x8D, 0x90, 0x4E, 0x51,
				0x37, 0xCB},
			true,
			[]byte{},
			"failed to return error when key is too short",
		},
	}

	for i, test := range tests {
		result, err := AES_256_CBC_encrypt(test.inputDataPlainText, test.inputDataKey, test.inputDataIV)

		if err != nil != test.expectedErr {
			t.Errorf("Expected error but did not return error on test case: %d, reason: %s", i, test.onErrorStr)
			continue
		}

		if !tools.CompareTwoByteSlices(result, test.expectedResult) {
			t.Errorf("Expected different ciphertext for test case: %d, %v != %v, reason: %s",
				i, result, test.expectedResult, test.onErrorStr)
		}
	}

}

func TestAES_256_CBC_decrypt(t *testing.T) {

	tests := []struct {
		inputDataCipherText []byte
		inputDataKey        []byte
		expectedErr         bool
		expectedResult      []byte
		onErrorStr          string
	}{
		{
			[]byte{0x92, 0xC8, 0x00, 0xA7, 0xEF, 0xE4, 0xD7, 0xF3, 0x5A, 0x76, 0x8D, 0x90, 0x4E,
				0x51, 0x37, 0xCB, 0x9D, 0xB6, 0xCB, 0x3A, 0xC0, 0x1B, 0xA9, 0xA8, 0xE4, 0xC6, 0xEA, 0x78, 0x29,
				0x4F, 0xA5, 0x4A},
			[]byte{0x63, 0x68, 0x61, 0x6E, 0x67, 0x65, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x70, 0x61,
				0x73, 0x73},
			false,
			[]byte{0x65, 0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x70, 0x6C, 0x61, 0x69, 0x6E, 0x74, 0x65,
				0x78, 0x74},
			"failed to decrypt valid ciphertext",
		},
		{
			[]byte{0x92, 0xC8, 0x00, 0xA7, 0xEF, 0xE4, 0xD7, 0xF3, 0x5A, 0x76, 0x8D, 0x90, 0x4E,
				0x51, 0x37, 0xCB, 0x9D, 0xB6, 0xCB, 0x3A, 0xC0, 0x1B, 0xA9, 0xA8, 0xE4, 0xC6, 0xEA, 0x78, 0x29,
				0x4F, 0xA5},
			[]byte{0x63, 0x68, 0x61, 0x6E, 0x67, 0x65, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x70, 0x61,
				0x73, 0x73},
			true,
			[]byte{},
			"failed to return error when ciphertext is not a multiple of the block size",
		},
		{
			[]byte{0x92, 0xC8, 0x00, 0xA7, 0xEF, 0xE4, 0xD7, 0xF3, 0x5A, 0x76, 0x8D, 0x90, 0x4E,
				0x51, 0x37, 0xCB, 0x9D, 0xB6, 0xCB, 0x3A, 0xC0, 0x1B, 0xA9, 0xA8, 0xE4, 0xC6, 0xEA, 0x78, 0x29,
				0x4F, 0xA5, 0x4A},
			[]byte{0x63, 0x68, 0x61, 0x6E, 0x67, 0x65, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x70, 0x61,
				0x73, 0x79},
			false,
			[]byte{0x43, 0x0B, 0x70, 0xE3, 0x87, 0x0E, 0x7D, 0x6B, 0x1A, 0x52, 0x09, 0xC4, 0xAC, 0x52,
				0x13, 0x67},
			"failed to decrypt valid ciphertext but with wrong key",
		},
	}

	for i, test := range tests {
		result, err := AES_256_CBC_decrypt(test.inputDataCipherText, test.inputDataKey)

		if err != nil != test.expectedErr {
			t.Errorf("Expected error but did not return error on test case: %d, reason: %s", i, test.onErrorStr)
			continue
		}

		if !tools.CompareTwoByteSlices(result, test.expectedResult) {
			t.Errorf("Expected different ciphertext for test case: %d, %v != %v, reason: %s",
				i, result, test.expectedResult, test.onErrorStr)
		}
	}

}

func TestAES_256_CBC_RandomIV(t *testing.T) {
	// See if multiple calls result in different values. There is a *very* tiny probability that we can generate
	// two identical IV's. Here is the probability:
	//
	// B(n,p) -> Binomial distribution where n is number of independent experiments and p is the probability of
	//			the event occurring.
	// n = 10 000 (const testNo)
	// p = (1/2^8)^16
	//
	// P(X > 0) = 1 - P(X = 0) = 1 - ( choose(10 000, 0) * p^0 * (1 - p)^10 000 ) = 1 - (1-p)^10 000 =
	//
	//											2.939 * 10^-35
	//   or in case scientific notation is not expressive enough = 0.00000000000000000000000000000000002939%
	//
	// Calculation: https://www.wolframalpha.com/input/?i=1-(1-(1%2F2%5E8)%5E16)%5E10000
	//
	// Essentially the probability is so small that is negligible. In case somebody is so lucky that
	// they come across such a scenario, you should probably play the lottery since you must an
	// extremely lucky person!

	const testNo = 10000
	results := make([][]byte, testNo)

	for i := 0; i < testNo; i++ {
		val, err := AES_256_CBC_RandomIV()

		if err != nil {
			t.Errorf("Error returned while generating random IV, iteration number: %d, error: %s", i, err)
		}

		results[i] = val
	}

	// See if any of the IV's are the same
	for i := 0; i < len(results); i++ {
		for j := 0; j < len(results); j++ {
			if i == j {
				continue
			}

			if tools.CompareTwoByteSlices(results[i], results[j]) {
				t.Errorf("Generated duplicate IV: %v", results[i])
			}
		}
	}

}

// Tests the following two functions:
// * AES_256_CBC_encrypt_with_padding()
// * AES_256_CBC_decrypt_with_padding()
//
// By first encrypting some byte slice and then decrypting it.
// If the decrypted plaintext matches the original everything works
// as expected.
func TestAES_256_CBC_encrypt_and_decrypt_with_padding(t *testing.T) {
	tests := []struct {
		inputDataPlaintext    []byte
		inputDataKeyEncrypt   []byte
		inputDataKeyDecrypt   []byte
		expectedErrEncrypting bool
		expectedErrDecrypting bool
		onErrorStr            string
	}{
		{
			[]byte{0x68, 0x65, 0x6C, 0x6C, 0x6F, 0x20, 0x77, 0x6F, 0x72, 0x6C, 0x64, 0x21},
			[]byte{0x49, 0x73, 0x20, 0x67, 0x6F, 0x64, 0x20, 0x72, 0x65, 0x61, 0x6C, 0x3F,
				0x20, 0x49, 0x44, 0x4B},
			[]byte{0x49, 0x73, 0x20, 0x67, 0x6F, 0x64, 0x20, 0x72, 0x65, 0x61, 0x6C, 0x3F,
				0x20, 0x49, 0x44, 0x4B},
			false,
			false,
			"failed to encrypt/decrypt with valid function calls",
		},
		{
			[]byte{0x68, 0x65, 0x6C, 0x6C, 0x6F, 0x20, 0x77, 0x6F, 0x72, 0x6C, 0x64, 0x21},
			[]byte{0x49, 0x73, 0x20, 0x67, 0x6F, 0x64, 0x20, 0x72, 0x65, 0x61, 0x6C, 0x3F,
				0x20, 0x49, 0x44, 0x4B},
			[]byte{0x49, 0x73, 0x20, 0x67, 0x6F, 0x64, 0x20, 0x72, 0x65, 0x61, 0x6C, 0x3F,
				0x20, 0x49, 0x44, 0x4A},
			false,
			false,
			"failed to encrypt/decrypt with valid function calls but with a bad decryption key",
		},
	}

	for i, test := range tests {
		ciphertext, err := AES_256_CBC_encrypt_with_padding(test.inputDataPlaintext, test.inputDataKeyEncrypt)

		if err != nil != test.expectedErrEncrypting {
			t.Errorf("Expected (or not) error on test case: %d, reason: %s", i, test.onErrorStr)
			continue
		}

		plaintext, err := AES_256_CBC_decrypt_with_padding(ciphertext, test.inputDataKeyDecrypt)

		keyValid := tools.CompareTwoByteSlices(test.inputDataKeyEncrypt, test.inputDataKeyDecrypt) // the same encryption/decryption key

		// && keyValid because if it is false, it means that we decrypted the message using a bad key and the
		// padding information is lost and can result in triggering an error (if the padding info denotes
		// a larger padding size than the data slice).
		if err != nil != test.expectedErrDecrypting && keyValid {
			t.Errorf("Expected (or not) error on test case: %d, err: %s, reason: %s", i, err, test.onErrorStr)
		}

		if keyValid {
			if !tools.CompareTwoByteSlices(plaintext, test.inputDataPlaintext) {
				t.Errorf("After encrypting the message and decrypting it, we received a different byte slice, test case: %d, %v != %v, reason: %s",
					i, plaintext, test.inputDataPlaintext, test.onErrorStr)
			}
		} else {
			if tools.CompareTwoByteSlices(plaintext, test.inputDataPlaintext) {
				t.Errorf("After encrypting the message and decrypting it with a wrong key, we received the same byte slice, test case: %d, %v != %v, reason: %s",
					i, plaintext, test.inputDataPlaintext, test.onErrorStr)
			}
		}

	}
}
